/* scripts/deriveSourcesFromDropHtml.mjs
 *
 * Generates src/data/sources_wiki.json from a saved Warframe drop table HTML.
 *
 * Fail-closed rules:
 * - We only map an HTML “Item” to a CatalogId when it matches exactly ONE display name in the catalog.
 * - If the name matches 0 or >1 catalog ids, it is written to unresolved output and skipped.
 *
 * Output:
 * - src/data/sources_wiki.json            (itemPath -> [{source}...])
 * - src/data/_generated/unresolved-drop-items.json
 * - src/data/_generated/source-label-map.auto.json (adds new labels deterministically, preserves existing)
 */

import fs from "node:fs";
import path from "node:path";
import process from "node:process";
import cheerio from "cheerio";

function argValue(flag) {
    const i = process.argv.indexOf(flag);
    if (i === -1) return null;
    return process.argv[i + 1] ?? null;
}

function must(v, msg) {
    if (!v) {
        console.error(msg);
        process.exit(1);
    }
    return v;
}

function readJsonFile(p, fallback) {
    try {
        if (!fs.existsSync(p)) return fallback;
        const txt = fs.readFileSync(p, "utf-8");
        const parsed = JSON.parse(txt);
        return parsed && typeof parsed === "object" ? parsed : fallback;
    } catch {
        return fallback;
    }
}

function writeJsonFile(p, obj) {
    fs.mkdirSync(path.dirname(p), { recursive: true });
    fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n", "utf-8");
}

function normalizeName(s) {
    return String(s ?? "").trim().toLowerCase();
}

function slugify(s) {
    return String(s ?? "")
        .trim()
        .toLowerCase()
        .replace(/['"]/g, "")
        .replace(/[^a-z0-9]+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 80);
}

function main() {
    const htmlPath = must(argValue("--html"), "Usage: node scripts/deriveSourcesFromDropHtml.mjs --html <path-to-saved-html>");
    const catalogPath = must(argValue("--catalog"), "Also required: --catalog <path-to-catalog-export.json>");
    const outPath = argValue("--out") ?? "src/data/sources_wiki.json";
    const unresolvedPath = argValue("--unresolved") ?? "src/data/_generated/unresolved-drop-items.json";
    const labelMapPath = argValue("--labelMap") ?? "src/data/_generated/source-label-map.auto.json";

    const html = fs.readFileSync(htmlPath, "utf-8");

    // catalog-export.json should be generated by a tiny helper you can run in your app build environment.
    // Shape expected:
    // {
    //   "nameIndex": { "<lower name>": ["items:/Lotus/..", ...] },
    //   "recordsById": { "<catalogId>": { "path": "/Lotus/..", "displayName": "...", ... } }
    // }
    const catalog = readJsonFile(catalogPath, null);
    if (!catalog || typeof catalog !== "object") {
        console.error(`Invalid catalog export JSON: ${catalogPath}`);
        process.exit(1);
    }

    const nameIndex = catalog.nameIndex ?? {};
    const recordsById = catalog.recordsById ?? {};

    const $ = cheerio.load(html);

    // The saved page includes multiple drop tables. Each table header is treated as a “source label”.
    // Warframe drop tables are commonly structured with a heading followed by a table with two columns:
    // - Item
    // - Chance/Rarity
    //
    // We extract:
    // - source label: nearest preceding heading text
    // - item name: first column text for each row that looks like a real item
    //
    // We skip rotation markers like "Rotation B" that appear as item rows.
    const sourcesByItemPath = {}; // { "/Lotus/...": [{source:"..."}] }

    const unresolved = {
        missingInCatalog: {},   // name -> { sourceLabels: [...] }
        ambiguousInCatalog: {}  // name -> { candidateCatalogIds: [...], sourceLabels: [...] }
    };

    // Load existing label map and preserve it.
    const labelMap = readJsonFile(labelMapPath, { byLabel: {}, defaults: { fallbackSourceId: "data:unknown" } });
    if (!labelMap.byLabel || typeof labelMap.byLabel !== "object") labelMap.byLabel = {};
    if (!labelMap.defaults || typeof labelMap.defaults !== "object") labelMap.defaults = { fallbackSourceId: "data:unknown" };
    if (!labelMap.defaults.fallbackSourceId) labelMap.defaults.fallbackSourceId = "data:unknown";

    function ensureLabelMapped(label) {
        const clean = String(label ?? "").trim();
        if (!clean) return;
        if (labelMap.byLabel[clean]) return;

        // Deterministic ID, but do NOT change existing assignments.
        const id = `data:${slugify(clean)}`;
        labelMap.byLabel[clean] = id;
    }

    function addUnresolved(bucket, name, payload) {
        if (!bucket[name]) {
            bucket[name] = payload;
            return;
        }
        const cur = bucket[name];
        const curLabels = new Set(cur.sourceLabels ?? []);
        for (const l of payload.sourceLabels ?? []) curLabels.add(l);
        bucket[name] = { ...cur, sourceLabels: Array.from(curLabels.values()).sort() };
    }

    function addSource(itemPath, sourceLabel) {
        if (!sourcesByItemPath[itemPath]) sourcesByItemPath[itemPath] = [];
        sourcesByItemPath[itemPath].push({ source: sourceLabel });
    }

    // Strategy: iterate all tables, derive a label from the closest previous heading.
    $("table").each((_, table) => {
        const t = $(table);

        // Find a nearby heading label (h1/h2/h3/h4) before the table.
        // Saved warframe drop pages often have an element like <h3>Earth/Cervantes (Spy)</h3> before the table.
        let label = "";
        const prevHead = t.prevAll("h1,h2,h3,h4").first();
        if (prevHead && prevHead.length) {
            label = prevHead.text().trim();
        }

        // Fallback: look for a thead th group label.
        if (!label) {
            const th = t.find("thead th").first();
            label = th.text().trim();
        }

        label = String(label ?? "").trim();
        if (!label) return;

        ensureLabelMapped(label);

        // Parse rows
        t.find("tbody tr").each((__, tr) => {
            const cols = $(tr).find("td");
            if (cols.length < 1) return;

            const itemName = $(cols.get(0)).text().replace(/\s+/g, " ").trim();
            if (!itemName) return;

            // Skip rotation marker rows and similar non-item lines.
            if (/^Rotation\s+[A-Z]$/i.test(itemName)) return;
            if (/^Rotation\s+[A-Z]\.\d+$/i.test(itemName)) return;

            const key = normalizeName(itemName);
            const candidates = Array.isArray(nameIndex[key]) ? nameIndex[key] : [];

            if (candidates.length === 0) {
                addUnresolved(unresolved.missingInCatalog, itemName, { sourceLabels: [label] });
                return;
            }

            if (candidates.length !== 1) {
                addUnresolved(unresolved.ambiguousInCatalog, itemName, {
                    candidateCatalogIds: candidates.slice(),
                    sourceLabels: [label]
                });
                return;
            }

            const catalogId = candidates[0];
            const rec = recordsById[catalogId];
            const itemPath = rec && typeof rec.path === "string" ? rec.path : null;

            if (!itemPath || !String(itemPath).startsWith("/")) {
                addUnresolved(unresolved.missingInCatalog, itemName, { sourceLabels: [label] });
                return;
            }

            addSource(itemPath, label);
        });
    });

    // Deduplicate sources per itemPath by label
    const out = {};
    for (const [itemPath, entries] of Object.entries(sourcesByItemPath)) {
        const seen = new Set();
        const uniq = [];
        for (const e of entries) {
            const s = String(e?.source ?? "").trim();
            if (!s || seen.has(s)) continue;
            seen.add(s);
            uniq.push({ source: s });
        }
        if (uniq.length) out[itemPath] = uniq;
    }

    // Sort output keys for stable diffs
    const sortedOut = {};
    for (const k of Object.keys(out).sort((a, b) => a.localeCompare(b))) {
        sortedOut[k] = out[k];
    }

    // Stable sort unresolved keys too
    function sortObjKeys(o) {
        const r = {};
        for (const k of Object.keys(o).sort((a, b) => a.localeCompare(b))) r[k] = o[k];
        return r;
    }
    unresolved.missingInCatalog = sortObjKeys(unresolved.missingInCatalog);
    unresolved.ambiguousInCatalog = sortObjKeys(unresolved.ambiguousInCatalog);

    writeJsonFile(outPath, sortedOut);
    writeJsonFile(unresolvedPath, unresolved);
    writeJsonFile(labelMapPath, labelMap);

    console.log(`Wrote: ${outPath}`);
    console.log(`Wrote: ${unresolvedPath}`);
    console.log(`Updated: ${labelMapPath}`);
    console.log(`Mapped item paths: ${Object.keys(sortedOut).length}`);
    console.log(`Unresolved (missing): ${Object.keys(unresolved.missingInCatalog).length}`);
    console.log(`Unresolved (ambiguous): ${Object.keys(unresolved.ambiguousInCatalog).length}`);
}

main();

